@inproceedings{damasPrincipalTypeschemesFunctional1982,
  title     = {Principal Type-Schemes for Functional Programs},
  booktitle = {Proceedings of the 9th {{ACM SIGPLAN-SIGACT}} Symposium on {{Principles}} of Programming Languages},
  author    = {Damas, Luis and Milner, Robin},
  date      = {1982-01-25},
  series    = {{{POPL}} '82},
  pages     = {207--212},
  publisher = {Association for Computing Machinery},
  location  = {New York, NY, USA},
  doi       = {10.1145/582153.582176},
  url       = {https://dl.acm.org/doi/10.1145/582153.582176},
  urldate   = {2025-02-07},
  isbn      = {978-0-89791-065-1}
}

@online{drawioltdDrawio,
  title = {Draw.Io},
  date = {2005},
  url = {https://www.drawio.com/},
  urldate = {2025-10-15},
  organization = {draw.io},
}

@online{EfficientInsightfulGeneralization2022,
  title   = {Efficient and {{Insightful Generalization}}},
  date    = {2022-01-09},
  url     = {https://okmij.org/ftp/ML/generalization.html},
  urldate = {2025-03-07},
}

@inproceedings{prattTopOperatorPrecedence1973,
  title     = {Top down Operator Precedence},
  booktitle = {Proceedings of the 1st Annual {{ACM SIGACT-SIGPLAN}} Symposium on {{Principles}} of Programming Languages},
  author    = {Pratt, Vaughan R.},
  date      = {1973-10-01},
  series    = {{{POPL}} '73},
  pages     = {41--51},
  publisher = {Association for Computing Machinery},
  location  = {New York, NY, USA},
  doi       = {10.1145/512927.512931},
  url       = {https://dl.acm.org/doi/10.1145/512927.512931},
  urldate   = {2025-02-07},
  isbn      = {978-1-4503-7349-4}
}

@online{Monomorphise,
  title   = {Monomorphise},
  date    = {2021-10-21},
  url     = {http://www.mlton.org/Monomorphise},
  urldate = {2025-09-14}
}

@article{brandonBetterDefunctionalizationLambda2023a,
  title        = {Better {{Defunctionalization}} through {{Lambda Set Specialization}}},
  author       = {Brandon, William and Driscoll, Benjamin and Dai, Frank and Berkow, Wilson and Milano, Mae},
  date         = {2023-06-06},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume       = {7},
  pages        = {977--1000},
  issn         = {2475-1421},
  doi          = {10.1145/3591260},
  url          = {https://dl.acm.org/doi/10.1145/3591260},
  urldate      = {2025-09-27},
  abstract     = {WILLIAM BRANDON∗, Massachusetts Institute of Technology, USA BENJAMIN DRISCOLL∗, Stanford University, USA FRANK DAI, WILSON BERKOW, and MAE MILANO, University of California, Berkeley, USA Higher-order functions pose a challenge for both static program analyses and optimizing compilers. To simplify the analysis and compilation of languages with higher-order functions, a rich body of prior work has proposed a variety of defunctionalization techniques, which can eliminate higher-order functions from a program by transforming the program to a semantically-equivalent first-order representation. Several modern languages take this a step further, specializing higher-order functions with respect to the functions on which they operate, and in turn allowing compilers to generate more efficient code. However, existing specializing defunctionalization techniques restrict how function values may be used, forcing implementations to fall back on costly dynamic alternatives. We propose lambda set specialization (LSS), the first specializing defunctionalization technique which imposes no restrictions on how function values may be used. We formulate LSS in terms of a polymorphic type system which tracks the flow of function values through the program, and use this type system to recast specialization of higher-order functions with respect to their arguments as a form of type monomorphization. We show that our type system admits a simple and tractable type inference algorithm, and give a formalization and fully-mechanized proof in the Isabelle/HOL proof assistant showing soundness and completeness of the type inference algorithm with respect to the type system. To show the benefits of LSS, we evaluate its impact on the run time performance of code generated by the MLton compiler for Standard ML, the OCaml compiler, and the new Morphic functional programming language. We find that pre-processing with LSS achieves run time speedups of up to 6.85× under MLton, 3.45× for OCaml, and 78.93× for Morphic. CCS Concepts: • Software and its engineering → Polymorphism; Procedures, functions and subroutines.},
  issue        = {PLDI},
  langid       = {english}
}

@software{lebedaTomLebedaChroma_code2025,
  title    = {{{TomLebeda}}/Chroma\_code},
  author   = {Lebeda, Tomáš},
  date     = {2025-07-06T20:54:28Z},
  origdate = {2023-08-18T17:27:36Z},
  url      = {https://github.com/TomLebeda/chroma_code},
  urldate  = {2025-09-28},
  abstract = {Make beautiful colored code listings in LaTeX with the power of TreeSitter.},
  keywords = {latex,listings,syntax-highlighting,tree-sitter}
}

@online{GarbageCollector,
  title   = {A Garbage Collector for {{C}} and {{C}}++},
  author = {Boehm, Hans and Demers, Alan and Weiser, Mark},
  date = {1988},
  url     = {https://www.hboehm.info/gc/},
  urldate = {2025-09-28},
}

@online{godboltCompilerExplorer,
  title = {Compiler {{Explorer}}},
  author = {Godbolt, Matt},
  url = {https://godbolt.org/},
  urldate = {2025-09-30},
}

@software{peterHyperfine2023,
  title = {Hyperfine},
  author = {Peter, David},
  date = {2023-03},
  origdate = {2018-01-13T15:49:54Z},
  url = {https://github.com/sharkdp/hyperfine},
  urldate = {2025-10-14},
  abstract = {A command-line benchmarking tool},
  version = {1.16.1}
}

@article{turingComputabilityLdefinability1937,
  title = {Computability and λ-Definability},
  author = {Turing, A. M.},
  date = {1937-12},
  journaltitle = {The Journal of Symbolic Logic},
  volume = {2},
  number = {4},
  pages = {153--163},
  issn = {0022-4812, 1943-5886},
  doi = {10.2307/2268280},
  url = {https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/computability-and-definability/FE8B4FC84276D7BACB8433BD578C6BFD},
  urldate = {2025-10-18},
  abstract = {Several definitions have been given to express an exact meaning corresponding to the intuitive idea of ‘effective calculability’ as applied for instance to functions of positive integers. The purpose of the present paper is to show that the computable functions introduced by the author are identical with the λ-definable functions of Church and the general recursive functions due to Herbrand and Gödel and developed by Kleene. It is shown that every λ-definable function is computable and that every computable function is general recursive. There is a modified form of λ-definability, known as λ-K-definability, and it turns out to be natural to put the proof that every λ-definable function is computable in the form of a proof that every λ-K-definable function is computable; that every λ-definable function is λ-K-definable is trivial. If these results are taken in conjunction with an already available proof that every general recursive function is λ-definable we shall have the required equivalence of computability with λ-definability and incidentally a new proof of the equivalence of λ-definability and λ-K-definability.A definition of what is meant by a computable function cannot be given satisfactorily in a short space. I therefore refer the reader to Computable pp. 230–235 and p. 254. The proof that computability implies recursiveness requires no more knowledge of computable functions than the ideas underlying the definition: the technical details are recalled in §5.},
  langid = {english}
}

@article{churchSetPostulatesFoundation1932,
  title = {A {{Set}} of {{Postulates}} for the {{Foundation}} of {{Logic}}},
  author = {Church, Alonzo},
  date = {1932},
  journaltitle = {Annals of Mathematics},
  volume = {33},
  number = {2},
  eprint = {1968337},
  eprinttype = {jstor},
  pages = {346--366},
  publisher = {[Annals of Mathematics, Trustees of Princeton University on Behalf of the Annals of Mathematics, Mathematics Department, Princeton University]},
  issn = {0003-486X},
  doi = {10.2307/1968337},
  url = {https://www.jstor.org/stable/1968337},
  urldate = {2025-10-18}
}

@software{brunsfeldTreesitterTreesitterV025102025,
  title = {Tree-Sitter/Tree-Sitter: V0.25.10},
  shorttitle = {Tree-Sitter/Tree-Sitter},
  author = {Brunsfeld, Max and Qureshi, Amaan and Hlynskyi, Andrew and ObserverOfTime and Lillis, Will and Vera, Josh and {dundargoc} and Turnbull, Phil and Clem, Timothy and Creager, Douglas and Helwer, Andrew and Rix, Rob and Kavolis, Daumantas and Clason, Christian and Davis, Michael and Bruins, Riley and Delpeuch, Antonin and Ika and Ya, Amin and Nguyễn, Tuấn-Anh and {bfredl} and Brunk, Stafford and Massicotte, Matt and Hasabnis, Niranjan and McCoy, James and Dong, Mingkai and Moelius, Samuel and Kalt, Steven and Kolja},
  date = {2025-09-22},
  doi = {10.5281/zenodo.17180150},
  url = {https://zenodo.org/records/17180150},
  urldate = {2025-10-18},
  abstract = {An incremental parsing system for programming tools},
  organization = {Zenodo},
}
